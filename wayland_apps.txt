= Writing and Porting Applications on Wayland =

This section is aimed for developers interested in building applications for
Wayland or porting existent ones to it.

In order to deploy applications on Linux systems, developers commonly use
widget library "toolkits" due their high-level nature of abstraction. Wayland
is an underlying implementation ("backend") for the toolkits, in a similar
way as X11 and DirectFB, and in principle should not require any changes on
applications. However, complex applications quite often want to access backend
routines in which was not exposed by a toolkit and in general they are free for
doing so. In this case, applications must be ported and the Wayland
implementation has to provide the needed functionalities. Section x.x
describes how Clutter toolkit could be used for application developers build a
client on Wayland. Specially it describes the "best-practices" in comparison
with a X11 environment and how to access native Wayland types from an
application built on Clutter. Likewise, Section x.x describes it all similarly
but on Qt 5 framework.

We remark that Wayland protocol is flexible in not defining any drawing
interface and virtually any abstraction library that lets you render into a
sharable buffer is enough. Therefore to give a better picture for application
developer, Section x.x shows how to write standalone OpenGL applications, using
EGL as window system binding. That section could be used also for developers
that want to understand the Wayland native types in general. The last section
outlines applications compatibility.

== Clutter ==

Clutter is toolkit for writing rich graphical animated applications on top of
OpenGL and OpenGL-ES. It uses the Wayland EGL abstraction to
integrate with Wayland.

Currently Clutter exposes no API that is Wayland specific - applications that
are developed without using any backend specific API (for example functions in the clutter_x11_ namespace) can be used without modification.

The wWayland backend for Clutter is still experimental however is it reasonably
mature. The backend has the following errata:

* Key repeat - holding the same key for a continous period of time does not
  generate periodic key events.
* The keyboard is hardcoded to a US keyboard for the keycode mapping -
  currently there is no mechanism in Wayland for setting the keymap to use.
* clutter_stage_set_user_resizable is a no-op - it should reject configures
  from the compositor that are not expected by the backend.
* Fullscreen behaviour has been observed to be flaky especially when calling
  clutter_stage_set_fullscreen before the stage is realised.

API to access the underlying wl_surface, wl_shell_surface and wl_display may
be available in later versions of the code but are not available right now.

== GTK+ ==

GTK+ is a toolkit best suited for building conventional desktop applications.
It has been ported to many platforms including X11, Quartz, Windows and now
Wayland. The Wayland port should be considered very experimental. 

The backend has the following errata:

* Programmatically changing the size of a window that has already been created
  (by the use of an expanding widget) will sometimes result in a window that
  does not have the correct contents
* Events from the scroll wheel (buttons 4 and 5) are not handled correctly
* Scrolling can result in distorted rendering - this is usually resolved the
  next time the window is fully repainted
* Copy and paste functionality is implemented however there may be certain
  cases that do not work - please report this as a bug
* Drag and drop is not implemented
* Occasionally the window surface may not be appear - try using
  gtk_widget_show_all on the top level window to force the windows to be
  visible - this bug is being actively worked on.
* The keyboard map is hard coded to a US pc105 keyboard
* Popup menus appear but do not have the correct grab behaviour and are not
  positioned in the correct location.

Due to the complexity of the GTK+ API implementing a complete and correct
backend is very challenging. You can assist this effort by filing any bugs
about missing functionality:
https://bugzilla.gnome.org/enter_bug.cgi?product=gtk+ in the Wayland
component.

== Qt 5 framework ==

Qt 5 is structured with the Lighthouse (or Qt Platform) Abstraction, which is
the windowing system and device agnostic architecture. That means Qt can load
in run-time different backend plugins for different window systems as desired.
For instance, an application developed on Qt could be run using "-platform
xcb" and "-platform wayland" for XCB or Wayland respectively and should have a
similar behavior on both systems, without the need to recompile.

Qt abstraction exposes to applications developers two native resources of
Wayland: wl_display and wl_surface. With those types, one could access
Wayland internals to deal with special cases through the interface:

    void *QPlatformNativeInterface::nativeResourceForWindow(const QByteArray &resource, QWindow *window)

Getting the display global handler is quite straightforward, as shown in the
following example:

    QPlatformNativeInterface *native =
        QGuiApplication::platformNativeInterface();
    struct wl_display *wl_dpy = (struct wl_display *)
        native->nativeResourceForWindow("display", NULL);

TODO: wl_surface

Differently from traditional X11 systems, Wayland gives more flexibility for
applications to control windows decoration and the way they are mapped on the
screen. Applications have to implement their own way of decorating windows.
Therefore, some Qt functions like setWindowTitle(), raise() or lower(), holding
window properties will have different effect on Wayland compositors.



TODO:
== per-toolkit "best practices" (Tiago/Rob) ==
        - E.g. explain how writing a GTK app under Wayland is different than
          X, same for Qt.  Highlight places where things may be different or
          have performance implications.
        - "don't use raw X calls", neither Wayland in principle but one would
          like to access native Wayland types for more robust and complex
          operation.
        - explain a bit about grabs and compare with the X style: grabs don't
          work the way they do under X.  Can't get window absolute position
          under Wayland.
        - how to get good performance? what not?
        - clutter code snips (bonus points for dnd, selection, etc)


== standalone OpenGL with EGL (Rob?) ==
        - How does one write low level EGL apps against Wayland? What about
          Cairo or just custom CPU rendered apps? This may come down to just
          documenting GBM nicely.
        - some code snips showing how to do so

== Applications Interoperability ==
        - define level of app compatibility; which classes of apps donâ€™t
          change, which need recompile, which need more.
        - we should also note something about compatibility here; Wayland apps
          for different verticals with different window system behavior may not
          behave the same; hopefully extensions for such will make it possible
          to write portable & scalable apps.

== misc ==
- why Wayland? Is it better than X? Memory wise is better? Simplicity? What,
  in the application's perspective? We have to somewhere document it around
  and try to be very clear in this regarding.
- something special for WM developers?
